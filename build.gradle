buildscript {
  ext {
    javaVersion = '1.8'
    vavrVersion = '0.9.2'
    slf4jVersion = '1.7.25'
    jgivenVersion = '0.15.3'
    logbackVersion = '1.2.3'
    lombokVersion = '1.18.4'
    junitJupiterVersion = '5.3.1'
    junitPlatformVersion = '1.3.0'
    assertjVersion = '3.11.1'
    hamcrestVersion = '1.3'
    junit4Version = '4.12'

    adocProcessingOutputDir = project.file("$buildDir/asciidoc" as String)
    adocOutputDir = project.file("$rootDir/target/generated-docs" as String)
  }

  dependencies {
    classpath 'org.asciidoctor:asciidoctorj-pdf:1.5.0-alpha.16'
    classpath 'org.jruby:jruby-complete:9.1.13.0'
  }
}

plugins {
  id 'com.gradle.build-scan' version '2.0.2'
  id 'com.avast.gradle.docker-compose' version '0.7.1'
  id 'org.asciidoctor.convert' version '1.5.8.1' apply false
  id 'org.ajoberstar.git-publish' version '2.0.0-rc.2' apply false
  id 'io.franzbecker.gradle-lombok' version '1.14' apply false
}

wrapper {
  gradleVersion = '5.0'
  distributionType = Wrapper.DistributionType.BIN
}

allprojects {
  apply plugin: 'base'
  version = '1.0.0-SNAPSHOT'
  group = 'com.github.daggerok.es'
  defaultTasks 'clean', 'install', 'build'
}

//subprojects { project ->
//  project.apply plugin: 'base'
//  if (project.subprojects.size() == 0
//      && !['bom', 'docs'].contains(project.name)) { // ignore ':bom' and ':docs' for now...
//    project.group = "$project.parent.group.$project.parent.name"
//  } 
//  else {
//    project.group = project.parent.group
//  }
//}

apply plugin: 'idea'
idea {
  module {
    downloadJavadoc = false
    downloadSources = true
  }
}

apply plugin: 'eclipse'
eclipse {
  classpath {
    downloadJavadoc = false
    downloadSources = true
  }
}

allprojects {
  apply plugin: 'base'
  clean.doFirst {
    [
        project.buildDir,
        project.file('out'),
        project.file('build'),
        adocOutputDir,
    ].each { delete it }
  }
}

allprojects {
  buildscript {
    apply from: "$rootDir/gradle/repositories-config.gradle"
  }
  apply from: "$rootDir/gradle/repositories-config.gradle"
}

allprojects {
  apply plugin: 'java'
  apply plugin: 'maven'
  sourceCompatibility = targetCompatibility = "$javaVersion"
  apply plugin: 'io.franzbecker.gradle-lombok'
  lombok.version = project.lombokVersion
  dependencies {
    implementation platform("io.vavr:vavr:$vavrVersion" as String)
    implementation platform("org.slf4j:slf4j-api:$slf4jVersion" as String)
    implementation platform("ch.qos.logback:logback-classic:$logbackVersion" as String)
    testImplementation platform("junit:junit:$junit4Version" as String)
    testImplementation platform("junit:junit:$junit4Version" as String)
    testImplementation platform("org.assertj:assertj-core:$assertjVersion" as String)
    testImplementation platform("org.hamcrest:hamcrest-core:$hamcrestVersion" as String)
    testImplementation platform("org.junit.jupiter:junit-jupiter-api:$junitJupiterVersion" as String)
    testImplementation platform("org.junit.jupiter:junit-jupiter-engine:$junitJupiterVersion" as String)
    testImplementation platform("org.junit.vintage:junit-vintage-engine:$junitJupiterVersion" as String)
    testImplementation platform("org.junit.platform:junit-platform-launcher:$junitPlatformVersion" as String)
    testImplementation platform('org.apiguardian:apiguardian-api:1.0.0')
    // In java we trust...
    compile 'io.vavr:vavr'
    compile 'org.slf4j:slf4j-api'
    compile 'ch.qos.logback:logback-classic'
  }
}

allprojects {
  dependencies {
    testImplementation 'junit:junit'
    testImplementation 'org.assertj:assertj-core'
    testImplementation 'org.hamcrest:hamcrest-core'
    testImplementation 'org.junit.jupiter:junit-jupiter-api'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'
    testRuntimeOnly 'org.junit.vintage:junit-vintage-engine'
    testRuntime 'org.junit.platform:junit-platform-launcher:'
    testCompileOnly 'org.apiguardian:apiguardian-api'
  }
  test {
    useJUnitPlatform {
      includeEngines 'junit-jupiter', 'junit-vintage'
    }
  }
}

allprojects {
  apply plugin: 'findbugs'
  tasks.withType(FindBugs) {
    reports {
      xml.enabled false
      html.enabled true
      //// see for details/example: https://github.com/findbugsproject/findbugs/blob/master/findbugs/src/xsl/default.xsl
      //html.stylesheet resources.text.fromFile('config/xsl/findbugs-custom.xsl')
    }
  }
  findbugs {
    reportsDir = file("$rootProject.buildDir/findbugs" as String)
    ignoreFailures = true
  }
}

allprojects {
  apply plugin: 'java'
  apply plugin: 'jacoco'
  jacoco {
    toolVersion = '0.8.1'
  }
  jacocoTestCoverageVerification {
    violationRules {
      rule {
        limit {
          minimum = 0.5
        }
      }
      rule {
        enabled = false
        element = 'CLASS'
        includes = [
            'org.gradle.*',
        ]
        limit {
          counter = 'LINE'
          value = 'TOTALCOUNT'
          maximum = 0.3
        }
      }
    }
  }
}
subprojects {
  jacocoTestReport {
    def main = sourceSets.main
    def srcDirs = main.allSource.srcDirs
    additionalSourceDirs = files(srcDirs)
    sourceDirectories = files(srcDirs)
    classDirectories = files(main.output)
    reports {
      xml.enabled = false
      csv.enabled = false
      html.enabled = true
      html.destination file("$buildDir/jacoco/html" as String)
    }
  }
}
jacocoTestReport {
  def main = subprojects.sourceSets.main
  def srcDirs = main.allSource.srcDirs
  dependsOn = subprojects.check
  additionalSourceDirs = files(srcDirs)
  sourceDirectories = files(srcDirs)
  classDirectories = files(main.output)
  executionData = files(subprojects.jacocoTestReport.executionData)
  afterEvaluate {
    classDirectories = files(classDirectories.files.collect {
      fileTree(
          dir    : it,
          exclude: [
              '*donot/check/me*',
              '*dont/check/metoo*',
          ]
      )
    })
  }
  reports {
    xml.enabled = false
    csv.enabled = false
    html.enabled = true
    html.destination file("$rootProject.buildDir/jacoco/html" as String)
  }
  onlyIf = {
    true
  }
  doFirst {
    executionData = files(executionData.findAll {
      it.exists()
    })
  }
}

def dockerComposeFile = project.file("$rootDir/docker-compose-gradle.yaml" as String)
if (project.hasProperty('profile')) {
  def profile = project.property('profile') ?: ''
  if (!profile.trim().isEmpty()) {
    def path = dockerComposeFile.absolutePath.replace('-gradle.yaml', "-${profile}.yaml" as String)
    dockerComposeFile = project.file(path)
  }
}
apply plugin: 'com.avast.gradle.docker-compose'
import static com.avast.gradle.dockercompose.RemoveImages.Local
dockerCompose {
  useComposeFiles = ["$dockerComposeFile"]
  captureContainersOutput = false // captureContainersOutput = true
  stopContainers = true
  removeContainers = true
  removeImages = Local
  removeVolumes = true
  removeOrphans = true
  forceRecreate = true
  waitForTcpPorts = false
  projectName = project.name
}
composeUp.dependsOn assemble
composeUp.shouldRunAfter clean, assemble

apply plugin: 'org.asciidoctor.convert'
apply plugin: 'org.ajoberstar.git-publish'
asciidoctor {
  sourceDir = project.file("$rootDir/docs" as String)
  sources {
    include 'index.adoc'
  }
  outputDir = adocProcessingOutputDir
  attributes toc: 'left',
      doctype: 'book',
      ruby: 'erubis',
      encoding: 'utf-8',
      linkattrs: true,
      numbered: true,
      sectanchors: true,
      sectlink: true,
      idprefix: '',
      docinfo1: '',
      icons: 'font',
      idseparator: '-',
      setanchors: 'true',
      imagesdir: './images',
      'toc-title': 'Table of Contents',
      'source-highlighter': 'highlightjs',
      'root-project-name': rootProject.name,
      'build-gradle': project.file('build.gradle'),
      'github-url': "https://github.com/daggerok/$rootProject.name",
      'gitlab-url': "https://gitlab.com/daggerok/$rootProject.name",
      'bitbucket-url': "https://bitbucket.com/daggerok/$rootProject.name"
  logDocuments = true
  backends = ['html5', 'pdf'] // backends 'pdf', 'html5'
}
asciidoctor.doLast {
  def html5 = "$adocProcessingOutputDir/html5"
  project.file("$html5/404.html" as String).text = project.file("$html5/index.html" as String).text
  project.file("$html5/.nojekyll" as String).text = ''
}
task documentation(type: Copy, dependsOn: asciidoctor) {
  shouldRunAfter clean, asciidoctor
  from("$asciidoctor.outputDir/html5" as String)
  from("$asciidoctor.outputDir/pdf" as String)
  from("$asciidoctor.sourceDir/static" as String) {
    into '.'
  }
  into adocOutputDir
}
gitPublish {
  repoUri = "git@github.com:daggerok/${rootProject.name}.git" as String
  branch = 'gh-pages'
  contents {
    from adocOutputDir, {
      into '.'
    }
  }
  commitMessage = "Publish $rootProject.name documentation (${project.group}:${project.name}:$project.version)" as String
}
gitPublishPush.dependsOn documentation
gitPublishPush.shouldRunAfter clean, documentation
task docs(dependsOn: gitPublishPush) {
  shouldRunAfter clean, asciidoctor
}

if (project.hasProperty('scan')) {
  buildScan {
    termsOfServiceUrl = 'https://gradle.com/terms-of-service'
    termsOfServiceAgree = 'yes'
    publishOnFailure()
    tag System.getProperty('os.name', 'unknown')
  }
}

allprojects {
  apply plugin: 'java'

  project.javadoc.failOnError = false

  task sourcesJar(type: Jar) {
    from sourceSets.main.allJava
    classifier 'sources'
  }

  task javadocJar(type: Jar) {
    from javadoc
    classifier 'javadoc'
  }

  apply plugin: 'maven-publish'

  publishing {
    publications {
      mavenJava(MavenPublication) {
        afterEvaluate {
          from components.java
          artifact sourcesJar
          artifact javadocJar
          //artifactId = jar.baseName

          pom {
            name = project.name
            description = project.description
            url = "https://github.com/daggerok/$project.name" as String
            licenses {
              license {
                name = 'MIT License'
                url = "https://github.com/daggerok/${project.name}/blob/master/LICENSE" as String
              }
            }
            developers {
              developer {
                id = 'daggerok'
                name = 'Maksim Kostromin'
                email = 'daggerok@gmail.com'
              }
            }
            scm {
              connection = "scm:git:git://github.com/daggeropk/${project.name}.git" as String
              developerConnection = "scm:git:ssh://github.com/daggeropk/${project.name}.git" as String
              url = "http://github.com/daggeropk/$project.name" as String
            }
          }
        }
      }
    }
  }

  publishing {
    repositories {
      maven {
        url """$rootProject.buildDir/maven-publish/repos/${(
            project.version.endsWith('SNAPSHOT') ? 'snapshots' : 'releases'
        )}"""
      }
    }
  }

  publish.dependsOn assemble

  /* // This one is required signatory to be configured (gpg stuff...)
  apply plugin: 'signing'

  signing {
    sign project.publishing.publications.mavenJava
  }
  */
}

/*
allprojects {
  // with shadow plugin
  publishing {
    publications {
      mavenJava(MavenPublication) { publication ->
        afterEvaluate {
          project.shadow.component(publication)
          artifact sourcesJar
          artifact javadocJar
          // ...
        }
      }
    }
  }
  // without shadow plugin
  publishing {
    publications {
      mavenJava(MavenPublication) ->
        artifact sourcesJar
        artifact javadocJar
      }
    }
  }
  // ...
}
*/
